{
    "sourceFile": "README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1635783342886,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1635783358890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,10 +27,10 @@\n             - dbt_datamocktool.unit_test:\n                 input_mapping:\n                   source('jaffle_shop', 'raw_customers'): ref('dmt__raw_customers_1')\n                 expected_output: ref('dmt__expected_stg_customers_1')\n-          depends_on: \n-            - raw_customers\n+                depends_on: \n+                  - raw_customers\n           columns:\n             ...\n \n         - name: stg_orders\n@@ -38,8 +38,10 @@\n             - dbt_datamocktool.unit_test:\n                 input_mapping:\n                   ref('raw_orders'): ref('dmt__raw_orders_1')\n                 expected_output: ref('dmt__expected_stg_orders_1')\n+                depends_on: \n+                  - raw_customers\n           columns:\n             ...\n 4. Run your tests: `dbt deps && dbt seed && dbt test`\n \n"
                }
            ],
            "date": 1635783342886,
            "name": "Commit-0",
            "content": "# datamocktool\n\n## About\ndatamocktool (dmt) is a simple package for unit testing dbt projects.\n\nUsing dmt, you can create mock CSV seeds to stand in for the sources and refs that your models use\nand test that the model produces the desired output (using another CSV seed).\n\n## Requirements\n* dbt version 0.19.2 or greater\n* BigQuery, Redshift, Postgres, or SQL Server (likely works on Snowflake but has not been specifically tested)\n\n## Quickstart\n1. Install this package by adding the following to your `packages.yml` file:\n    * ```yaml \n        - package: mjirv/dbt_datamocktool\n          version: [\">=0.1.4\"]\n    * Note that for the revision, you can also use `0.1.2` if other packages require fishtown-analytics/dbt_utils instead of dbt-labs/dbt_utils (most other functionality is the same).\n2. Create your mocks: sample inputs for your models and the expected outputs of those models given the inputs.\n    * Save them to your seeds directory (usually `data/`; note that you can use any folder structure you would like within that directory)\n    * See the `integration_tests/data/` directory of this project for some examples\n3. Define your tests: Add unit tests to your `schema.yml` files, using the following example: \n    * ```yaml\n        models:\n        - name: stg_customers\n          tests:\n            - dbt_datamocktool.unit_test:\n                input_mapping:\n                  source('jaffle_shop', 'raw_customers'): ref('dmt__raw_customers_1')\n                expected_output: ref('dmt__expected_stg_customers_1')\n          depends_on: \n            - raw_customers\n          columns:\n            ...\n\n        - name: stg_orders\n          tests:\n            - dbt_datamocktool.unit_test:\n                input_mapping:\n                  ref('raw_orders'): ref('dmt__raw_orders_1')\n                expected_output: ref('dmt__expected_stg_orders_1')\n          columns:\n            ...\n4. Run your tests: `dbt deps && dbt seed && dbt test`\n\n## Advanced Usage\n### Using Other Materializations\nInputs can also be models, SQL statements, and/or macros instead of seeds. See `integration_tests/macros/dmt_raw_customers.sql` and the related test in `integration_tests/models/staging/schema.yml` where this is implemented (copied below).\n\nNote that you must wrap your SQL in parentheses in order to create a valid subquery, as below.\n\nExpected outputs _must_ be seeds or models because the `dbt_utils.equality` test expects a relation. If you want to write SQL instead of a CSV for the expectation, you can use a model that is materialized as a view. See `integration_tests/models/unit_test_helpers/dmt__expected_stg_customers_2.sql` where this is implemented (copied below).\n\nTest:\n```yaml\n  - dbt_datamocktool.unit_test:\n            input_mapping:\n              source('jaffle_shop', 'raw_customers'): \"{{ dmt_raw_customers() }}\" # this is a macro\n            expected_output: ref('dmt__expected_stg_customers_2') # this is a model\n```\n\nModel (expected output):\n```sql\n  {{\n      config(materialized='view')\n  }}\n\n  select 1 as customer_id, 'Michael' as first_name, 'P.' as last_name\n  union all\n  select 2 as customer_id, 'Shawn' as first_name, 'M.' as last_name\n```\n\nMacro (input):\n```sql\n  {% macro dmt_raw_customers() %}\n    (\n\n    {% set records = [\n        [1,\"Michael\",\"P.\"],\n        [2,\"Shawn\",\"M.\"]\n    ] %}\n\n    {% for record in records %}\n        select {{ record[0] }} as id, '{{ record[1] }}' as first_name, '{{ record[2] }}' as last_name\n        {% if not loop.last %}\n            union all\n        {% endif %}\n    {% endfor %}\n    ) raw_customers\n{% endmacro %}\n```\n\n### Test Names/Descriptions\nYou can add optional names and descriptions to your tests to make them easier to work with.\n\nFor example:\n```yaml\n      - dbt_datamocktool.unit_test:\n          input_mapping:\n            source('jaffle_shop', 'raw_customers'): \"{{ dmt_raw_customers() }}\" # this is a macro\n          expected_output: ref('dmt__expected_stg_customers_2') # this is a model\n          name: \"Raw Customers 2\"\n          description: \"This test is a unit test\"\n```\n\nwill show up in your test run as follows:\n```python\n21:37:48 | 4 of 23 START test dbt_datamocktool_unit_test_stg_customers_This_test_is_a_unit_test__ref_dmt__expected_stg_customers_2____dmt_raw_customers___Raw_Customers_2 [RUN]\n21:37:49 | 4 of 23 PASS dbt_datamocktool_unit_test_stg_customers_This_test_is_a_unit_test__ref_dmt__expected_stg_customers_2____dmt_raw_customers___Raw_Customers_2 [PASS in 0.27s]\n```"
        }
    ]
}